package services

import (
	"encoding/json"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/TomasZmek/cpm/internal/models"
)

// WildcardService manages wildcard SSL certificate configurations
type WildcardService struct {
	configPath string
}

// NewWildcardService creates a new WildcardService
func NewWildcardService(configDir string) *WildcardService {
	return &WildcardService{
		configPath: filepath.Join(configDir, "wildcard.json"),
	}
}

// GetConfig returns the current wildcard configuration
func (s *WildcardService) GetConfig() (*models.WildcardConfig, error) {
	config := &models.WildcardConfig{
		Domains: []models.WildcardDomain{},
	}

	data, err := os.ReadFile(s.configPath)
	if err != nil {
		if os.IsNotExist(err) {
			return config, nil
		}
		log.Printf("Error reading wildcard config: %v", err)
		return config, nil // Return empty config on error
	}

	if err := json.Unmarshal(data, config); err != nil {
		log.Printf("Error parsing wildcard config (invalid JSON?): %v", err)
		// Return empty config, don't fail
		return &models.WildcardConfig{
			Domains: []models.WildcardDomain{},
		}, nil
	}

	return config, nil
}

// SaveConfig saves the wildcard configuration
func (s *WildcardService) SaveConfig(config *models.WildcardConfig) error {
	// Ensure directory exists
	dir := filepath.Dir(s.configPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		log.Printf("Error creating config directory: %v", err)
		return err
	}

	data, err := json.MarshalIndent(config, "", "  ")
	if err != nil {
		log.Printf("Error marshaling wildcard config: %v", err)
		return err
	}

	if err := os.WriteFile(s.configPath, data, 0644); err != nil {
		log.Printf("Error writing wildcard config: %v", err)
		return err
	}
	
	log.Printf("Wildcard config saved to %s", s.configPath)
	return nil
}

// AddDomain adds a new wildcard domain
func (s *WildcardService) AddDomain(domain models.WildcardDomain) error {
	log.Printf("AddDomain: %s (provider: %s)", domain.Domain, domain.Provider)
	
	config, err := s.GetConfig()
	if err != nil {
		log.Printf("Error getting config in AddDomain: %v", err)
		return err
	}

	// Check if domain already exists
	for _, d := range config.Domains {
		if d.Domain == domain.Domain {
			log.Printf("Domain %s already exists, updating", domain.Domain)
			return s.UpdateDomain(domain)
		}
	}

	config.Domains = append(config.Domains, domain)
	return s.SaveConfig(config)
}

// UpdateDomain updates an existing wildcard domain
func (s *WildcardService) UpdateDomain(domain models.WildcardDomain) error {
	config, err := s.GetConfig()
	if err != nil {
		return err
	}

	for i, d := range config.Domains {
		if d.Domain == domain.Domain {
			config.Domains[i] = domain
			return s.SaveConfig(config)
		}
	}

	// Not found, add it
	return s.AddDomain(domain)
}

// DeleteDomain removes a wildcard domain
func (s *WildcardService) DeleteDomain(domain string) error {
	config, err := s.GetConfig()
	if err != nil {
		return err
	}

	newDomains := []models.WildcardDomain{}
	for _, d := range config.Domains {
		if d.Domain != domain {
			newDomains = append(newDomains, d)
		}
	}

	config.Domains = newDomains
	return s.SaveConfig(config)
}

// GetDomains returns all wildcard domains
func (s *WildcardService) GetDomains() ([]models.WildcardDomain, error) {
	config, err := s.GetConfig()
	if err != nil {
		return nil, err
	}
	return config.Domains, nil
}

// GenerateCaddyConfig generates Caddy TLS configuration for wildcard domains
// This creates a snippet that can be imported by other sites
func (s *WildcardService) GenerateCaddyConfig() (string, error) {
	config, err := s.GetConfig()
	if err != nil {
		return "", err
	}

	if len(config.Domains) == 0 {
		return "", nil
	}

	var result string
	result += "# Wildcard TLS configuration - Auto-generated by CPM\n"
	result += "# Import this in your site configs with: import wildcard-tls-<domain>\n\n"

	for _, domain := range config.Domains {
		var tokenSource string
		if domain.UseEnv {
			tokenSource = "{env.CF_API_TOKEN}"
		} else {
			tokenSource = domain.APIToken
		}

		// Generate snippet for wildcard TLS
		snippetName := "wildcard-tls-" + strings.ReplaceAll(domain.Domain, ".", "-")
		
		result += "# Wildcard TLS snippet for *." + domain.Domain + "\n"
		result += "(" + snippetName + ") {\n"
		result += "    tls {\n"
		
		switch domain.Provider {
		case "cloudflare":
			result += "        dns cloudflare " + tokenSource + "\n"
		default:
			result += "        dns cloudflare " + tokenSource + "\n"
		}
		
		result += "    }\n"
		result += "}\n\n"
	}

	return result, nil
}

// GetSnippetName returns the snippet name for a domain
func GetSnippetName(domain string) string {
	return "wildcard-tls-" + strings.ReplaceAll(domain, ".", "-")
}

// MigrationInfo contains info about sites/certs that can be migrated
type MigrationInfo struct {
	Domain       string
	SnippetName  string
	MatchingSites []string  // Site filenames that match *.domain
	Certificates  []string  // Certificate domains that match *.domain
}

// GetMigrationInfo returns info about what can be migrated for a wildcard domain
func (s *WildcardService) GetMigrationInfo(domain string, sitesDir string, certsDataDir string) (*MigrationInfo, error) {
	info := &MigrationInfo{
		Domain:       domain,
		SnippetName:  GetSnippetName(domain),
		MatchingSites: []string{},
		Certificates:  []string{},
	}

	// Find matching site files
	if entries, err := os.ReadDir(sitesDir); err == nil {
		for _, entry := range entries {
			if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".caddy") {
				continue
			}
			// Skip wildcard config itself
			if entry.Name() == "_wildcard.caddy" {
				continue
			}
			
			// Read file and check if it contains subdomains of our domain
			content, err := os.ReadFile(filepath.Join(sitesDir, entry.Name()))
			if err != nil {
				continue
			}
			
			// Simple check: if file contains .domain (e.g., .zrnek.cz)
			if strings.Contains(string(content), "."+domain) {
				info.MatchingSites = append(info.MatchingSites, entry.Name())
			}
		}
	}

	// Find matching certificates
	certsDir := filepath.Join(certsDataDir, "certificates")
	if entries, err := os.ReadDir(certsDir); err == nil {
		for _, issuerDir := range entries {
			if !issuerDir.IsDir() {
				continue
			}
			issuerPath := filepath.Join(certsDir, issuerDir.Name())
			if certDirs, err := os.ReadDir(issuerPath); err == nil {
				for _, certDir := range certDirs {
					certName := certDir.Name()
					// Check if cert is for a subdomain of our domain
					if strings.HasSuffix(certName, "."+domain) && certName != "*."+domain {
						info.Certificates = append(info.Certificates, certName)
					}
				}
			}
		}
	}

	return info, nil
}

// MigrateSiteConfig migrates a single site config to use wildcard TLS
func (s *WildcardService) MigrateSiteConfig(sitePath string, snippetName string) error {
	content, err := os.ReadFile(sitePath)
	if err != nil {
		return err
	}

	original := string(content)
	modified := original

	// Check if already has the import
	if strings.Contains(modified, "import "+snippetName) {
		log.Printf("Site %s already has wildcard import", sitePath)
		return nil
	}

	// Remove existing tls { } blocks (simple regex-like approach)
	// This is a simplified version - handles common cases
	lines := strings.Split(modified, "\n")
	var newLines []string
	inTlsBlock := false
	braceCount := 0
	
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		
		// Detect start of tls block
		if strings.HasPrefix(trimmed, "tls") && strings.Contains(line, "{") {
			inTlsBlock = true
			braceCount = 1
			continue
		}
		
		if inTlsBlock {
			braceCount += strings.Count(line, "{") - strings.Count(line, "}")
			if braceCount <= 0 {
				inTlsBlock = false
			}
			continue
		}
		
		newLines = append(newLines, line)
	}
	
	modified = strings.Join(newLines, "\n")

	// Add import after first { 
	// Find the first site block opening
	firstBrace := strings.Index(modified, "{")
	if firstBrace != -1 {
		// Insert import after the opening brace
		insertPos := firstBrace + 1
		importLine := "\n    import " + snippetName
		modified = modified[:insertPos] + importLine + modified[insertPos:]
	}

	// Write back
	if err := os.WriteFile(sitePath, []byte(modified), 0644); err != nil {
		return err
	}

	log.Printf("Migrated site %s to use wildcard TLS", sitePath)
	return nil
}
