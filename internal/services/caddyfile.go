package services

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/TomasZmek/cpm/internal/config"
	"github.com/TomasZmek/cpm/internal/models"
)

// CaddyfileManager handles Caddyfile generation and wildcard block management
type CaddyfileManager struct {
	config          *config.Config
	wildcardService *WildcardService
	snippetsService *SnippetsService
}

// NewCaddyfileManager creates a new CaddyfileManager
func NewCaddyfileManager(cfg *config.Config, ws *WildcardService, ss *SnippetsService) *CaddyfileManager {
	return &CaddyfileManager{
		config:          cfg,
		wildcardService: ws,
		snippetsService: ss,
	}
}

// EnsureDirectoryStructure creates required directories
func (m *CaddyfileManager) EnsureDirectoryStructure() error {
	dirs := []string{
		filepath.Join(m.config.SitesDir, "wildcard"),
		filepath.Join(m.config.SitesDir, "standard"),
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	return nil
}

// GetSiteDirectory returns the correct directory for a site based on its type
func (m *CaddyfileManager) GetSiteDirectory(site *models.Site) string {
	if site.IsWildcard() {
		return filepath.Join(m.config.SitesDir, "wildcard")
	}
	return filepath.Join(m.config.SitesDir, "standard")
}

// GetSiteFilename returns the filename with correct suffix for wildcard sites
func (m *CaddyfileManager) GetSiteFilename(site *models.Site) string {
	baseName := sanitizeFilename(site.PrimaryDomain())
	
	if site.IsWildcard() {
		// For wildcard sites, use pattern: name.domain.caddy
		// e.g., home.perteus.cz.caddy
		return baseName + ".caddy"
	}
	
	return baseName + ".caddy"
}

// GenerateCaddyfile generates the main Caddyfile with wildcard blocks
func (m *CaddyfileManager) GenerateCaddyfile() (string, error) {
	var lines []string

	// Global settings
	lines = append(lines, "# Caddyfile - Auto-generated by CPM v3.1.0")
	lines = append(lines, "# DO NOT EDIT MANUALLY - Use the CPM web interface")
	lines = append(lines, "{")
	lines = append(lines, "    # email your@email.com")
	lines = append(lines, "}")
	lines = append(lines, "")
	lines = append(lines, "import /etc/caddy/snippets.caddy")
	lines = append(lines, "")

	// Get wildcard domains
	wildcardDomains, err := m.wildcardService.GetDomains()
	if err != nil {
		return "", fmt.Errorf("failed to get wildcard domains: %w", err)
	}

	// Get internal networks from snippets config
	internalNetworks := m.getInternalNetworks()

	// Generate wildcard blocks
	if len(wildcardDomains) > 0 {
		lines = append(lines, "# === WILDCARD DOMAINS ===")
		lines = append(lines, "")

		for _, wd := range wildcardDomains {
			block := m.generateWildcardBlock(wd, internalNetworks)
			lines = append(lines, block)
			lines = append(lines, "")
		}
	}

	// Standard sites import
	lines = append(lines, "# === STANDARD SITES ===")
	lines = append(lines, "import /etc/caddy/sites/standard/*.caddy")
	lines = append(lines, "")

	// Legacy support - import old style sites that aren't in subdirectories
	lines = append(lines, "# === LEGACY SITES (for migration) ===")
	lines = append(lines, "# import /etc/caddy/sites/*.caddy")

	return strings.Join(lines, "\n") + "\n", nil
}

// generateWildcardBlock generates a complete wildcard block for Caddyfile
func (m *CaddyfileManager) generateWildcardBlock(wd models.WildcardDomain, internalNetworks []string) string {
	var lines []string
	
	snippetName := "wildcard-tls-" + strings.ReplaceAll(wd.Domain, ".", "-")
	importPattern := fmt.Sprintf("/etc/caddy/sites/wildcard/*.%s.caddy", wd.Domain)

	lines = append(lines, fmt.Sprintf("# --- %s ---", strings.ToUpper(wd.Domain)))
	lines = append(lines, fmt.Sprintf("*.%s {", wd.Domain))
	lines = append(lines, fmt.Sprintf("    import %s", snippetName))
	
	// Internal network restriction - MUST be before site imports and outside handle blocks
	// This replaces per-site internal_only snippet for wildcard sites
	if len(internalNetworks) > 0 {
		networks := strings.Join(internalNetworks, " ")
		lines = append(lines, "")
		lines = append(lines, "    # Internal network restriction (replaces internal_only for wildcard sites)")
		lines = append(lines, fmt.Sprintf("    @internal_denied not client_ip %s", networks))
		lines = append(lines, "    handle @internal_denied {")
		lines = append(lines, "        error 403")
		lines = append(lines, "    }")
	}
	
	lines = append(lines, "")
	lines = append(lines, "    # Import site-specific handle blocks")
	lines = append(lines, fmt.Sprintf("    import %s", importPattern))
	lines = append(lines, "")
	
	// Error pages - must be at wildcard level, not inside handle blocks
	lines = append(lines, "    # Error handling")
	lines = append(lines, "    handle_errors {")
	lines = append(lines, "        @403 expression {http.error.status_code} == 403")
	lines = append(lines, "        handle @403 {")
	lines = append(lines, "            root * /usr/share/caddy/pages")
	lines = append(lines, "            rewrite * /403.html")
	lines = append(lines, "            file_server")
	lines = append(lines, "        }")
	lines = append(lines, "        @404 expression {http.error.status_code} == 404")
	lines = append(lines, "        handle @404 {")
	lines = append(lines, "            root * /usr/share/caddy/pages")
	lines = append(lines, "            rewrite * /404.html")
	lines = append(lines, "            file_server")
	lines = append(lines, "        }")
	lines = append(lines, "    }")
	lines = append(lines, "")
	lines = append(lines, "    # Default handler (no matching site)")
	lines = append(lines, "    handle {")
	lines = append(lines, "        abort")
	lines = append(lines, "    }")
	lines = append(lines, "}")

	return strings.Join(lines, "\n")
}

// getInternalNetworks returns the internal networks from snippets config
func (m *CaddyfileManager) getInternalNetworks() []string {
	if m.snippetsService == nil {
		return []string{"192.168.0.0/16", "172.16.0.0/12", "10.0.0.0/8"}
	}

	cfg, err := m.snippetsService.GetConfig()
	if err != nil {
		return []string{"192.168.0.0/16", "172.16.0.0/12", "10.0.0.0/8"}
	}

	if !cfg.InternalOnly.Enabled || len(cfg.InternalOnly.AllowedNetworks) == 0 {
		return []string{}
	}

	return cfg.InternalOnly.AllowedNetworks
}

// SaveCaddyfile writes the generated Caddyfile to disk
func (m *CaddyfileManager) SaveCaddyfile() error {
	content, err := m.GenerateCaddyfile()
	if err != nil {
		return err
	}

	caddyfilePath := filepath.Join(m.config.ConfigDir, "Caddyfile")
	return os.WriteFile(caddyfilePath, []byte(content), 0644)
}

// MigrateSiteToNewStructure moves a site file to the correct directory
func (m *CaddyfileManager) MigrateSiteToNewStructure(site *models.Site) error {
	if err := m.EnsureDirectoryStructure(); err != nil {
		return err
	}

	newDir := m.GetSiteDirectory(site)
	newFilename := m.GetSiteFilename(site)
	newPath := filepath.Join(newDir, newFilename)

	// Generate new content
	content := site.ToCaddyfile()

	// Write to new location
	if err := os.WriteFile(newPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write site file: %w", err)
	}

	// Remove old file if it exists in different location
	if site.Filepath != "" && site.Filepath != newPath {
		if _, err := os.Stat(site.Filepath); err == nil {
			os.Remove(site.Filepath)
		}
	}

	return nil
}

// RegenerateCaddyfileForWildcard regenerates Caddyfile when wildcard config changes
func (m *CaddyfileManager) RegenerateCaddyfileForWildcard() error {
	return m.SaveCaddyfile()
}
